package pasa.cbentley.framework.gui.src4.anim.definitions;

import pasa.cbentley.byteobjects.src4.core.ByteObject;
import pasa.cbentley.byteobjects.src4.objects.function.Function;
import pasa.cbentley.core.src4.interfaces.C;
import pasa.cbentley.core.src4.logging.Dctx;
import pasa.cbentley.framework.gui.src4.anim.base.DrawableAnim;
import pasa.cbentley.framework.gui.src4.core.Drawable;
import pasa.cbentley.framework.gui.src4.ctx.GuiCtx;
import pasa.cbentley.framework.gui.src4.interfaces.IDrawable;

/**
 * Two {@link Function} that decides the width and height.
 * <li> one function might increase a little the width and the other decrease a little the height.
 * 
 * <br>
 * Function takes original width and modifies it.
 * <br>
 * <br>
 * What controls the turns?<br>
 * {@link DrawableAnim} step function. It clocks and decides how many steps between the final 
 * <br>
 * <br>
 * <b>Case 1 : Absolute</b> <br>
 * Function values are computed in absolute for all {@link Drawable}'s sizes.
 * W=100 H=100<br>
 * We want W to lose 10 pixels in 5 steps.<br>
 * We want H to gain 50 pixels in 5 steps.<br>
 * This reaches a state of W=90 - H=150 in 5 animations steps.<br>
 * <li>Fw = 2,4,6,8,10
 * <li>Fh = 10,20,30,40,50
 * <br>
 * Values are precomputed absolute. Not relative to actual size.<br>
 * <br>
 * Drawable start Size is + the function values. 
 * <br>
 * Stepping change is decide
 * <li>10 Steps gives 1 pixel for the W and 5 pixel for the H
 * <br>
 * <br>
 * <b>Case 2 : Relative</b>
 * <br>
 * Values are computed relative to {@link Drawable} initial size.
 * <br>
 * From given value (0 or X) to actual Size or
 * <li> the reverse {@link IFunction#FUN_COUNTER_OP_1_DESC} 
 * <li> or both ( {@link IFunction#FUN_COUNTER_OP_3_UP_DOWN}.<br>
 * <br>
 * 5 steps<br>
 * <br>
 * <li>W=20 20/5 = 4 => 4,8,12,16,20 [first step excluded]
 * <li>H=50 50/5 = 10 => 10,20,30,40,50
 * <br>
 * Step where both w and h are zero is not included. Wasted time.
 * <br>
 * Last step may also be excluded
 * <br>
 * <br>
 * <b>Case 3 : Percentages</b> <br>
 * Absolute/Relative values computed from the initial size.
 * Values are percentage 
 * <li> Fw = 10%,15%,10%,20%,15%,25%.
 * 
 * <br>
 * <br>
 * Function values are computed in the {@link SizeMod#lifeStart()} method from Tech Parameters.
 * 
 * <br>
 * <br>
 * Animation must be notified of Drawable dimension changes generated by a call not made by this class.
 * <br>
 * <br>
 * @author Charles-Philip Bentley
 *
 */
public class SizeMod extends DrawableAnim {
   public static int       GENES                    = ANIM_02_REVERSABLE;

   public static final int SIZE_MOD_OFFSET_2_DEST_W = 0;

   /**
    * Anchors the size modification to a point
    * <br>
    * <li>{@link C#ANC_0_TOP_LEFT} : easiest
    * <li>{@link C#ANC_1_TOP_CENTER} modifies x position
    * <li>{@link C#ANC_2_TOP_RIGHT} modifies x position
    * <li>{@link C#ANC_3_CENTER_LEFT} 
    * <li>{@link C#ANC_4_CENTER_CENTER} : heart pump effect
    * <li>{@link C#ANC_5_CENTER_RIGHT} 
    * <li>{@link C#ANC_6_BOT_LEFT} 
    * <li>{@link C#ANC_7_BOT_CENTER} 
    * <li>{@link C#ANC_8_BOT_RIGHT}       
    */
   private int             anchor;

   private Function        heightF;

   private boolean         isImp                    = false;

   private int             sizeH;

   private int             sizeW;

   private int             startH;

   /**
    *  Animation must update startW when it is changed outside of the animations.
    */
   private int             startW;

   private int             valH;

   private int             valW;

   private Function        widthF;

   private int             startX;

   private int             startY;


   /**
    * 
    * @param d
    * @param f template
    */
   public SizeMod(GuiCtx gc, IDrawable d, Function f) {
      super(gc, d, f);
   }

   /**
    * No {@link ByteObject} of the function.
    * @param d
    * @param wf
    * @param hf
    */
   public SizeMod(GuiCtx gc, IDrawable d, Function wf, Function hf) {
      super(gc, d, (Function) null);
      widthF = wf;
      heightF = hf;
      stepFunction = widthF;
   }

   public SizeMod(GuiCtx gc, IDrawable d, Function fTick, Function wf, Function hf) {
      super(gc, d, fTick);
      widthF = wf;
      heightF = hf;
   }

   private void initSizes() {
      //sizeW = d.getInitWidth();
      //sizeH = d.getInitHeight();

      startW = d.getDrawnWidth();
      startH = d.getDrawnHeight();

      startX = d.getX();
      startY = d.getY();
   }

   public void lifeEnd() {
      d.init(sizeW, sizeH);
      super.lifeEnd();
   }

   public void setAnchor(int ancor) {
      anchor = ancor;
   }

   /**
    * Function depends on size.
    * Ask the Function to compute all values. 
    * <br>
    * Animation must update startW and start
    */
   public void lifeStart() {
      //init functions with most of our functions should be made here just give values to the function
      //and be done with it.s
      //Type of function is given by Animation definition

      //evolving end after each animation? use an action + function pointer for the end value
      //      int[] wValues = MUtils.getValues(widthF.getNumSteps(), startW, tech.get2(SIZE_MOD_OFFSET_2_DEST_W));
      //      
      //      widthF.reset(wValues);
      //      
      //      heightF.initFct(d.getDrawnHeight());

      super.lifeStart();
   }

   /**
    * Function values 
    */
   public void nextTurnSub() {
      //give current value. function decides if it needs it.
      //      if (d.getInitHeight() != valH || d.getInitWidth() != valW) {
      //         initSizes();
      //      }
      int w = startW + widthF.fValues();
      int h = startH + heightF.fValues();
      //
      valW = w;
      valH = h;
      d.init(w, h);
      int newX = startX;
      int newY = startY;
      switch (anchor) {
         case C.ANC_0_TOP_LEFT:
            break;
         case C.ANC_1_TOP_CENTER:
            newX += ((startW - w) / 2);
            break;
         case C.ANC_2_TOP_RIGHT:
            newX += (w - startW);
            break;
         case C.ANC_3_CENTER_LEFT:
            newY += ((startY - h) / 2);
            break;
         case C.ANC_4_CENTER_CENTER:
            newX += ((startW - w) / 2);
            newY += ((startY - h) / 2);
            break;
         case C.ANC_5_CENTER_RIGHT:
            newX += (w - startW);
            newY += ((startY - h) / 2);
            break;
         case C.ANC_6_BOT_LEFT:
            newY += (h - startH);
            break;
         case C.ANC_7_BOT_CENTER:
            newX += ((startW - w) / 2);
            newY += (h - startH);
            break;
         case C.ANC_8_BOT_RIGHT:
            newX += (w - startW);
            newY += (h - startH);
            break;
         default:
            break;
      }
      d.setXY(newX, newY);
   }

   public void reset() {

      super.reset();
   }

   //#mdebug
   public void toString(Dctx dc) {
      dc.root(this, "SizeMod");
      dc.append(" originalSize " + sizeW + "," + sizeH + " startSize=" + startW + "," + startH);
      dc.nlLvl("Width", widthF);
      dc.nlLvl("Height", heightF);

      super.toString(dc.sup());
   }

   public void toString1Line(Dctx dc) {
      dc.root1Line(this, "SizeMod");
   }

   //#enddebug

}
