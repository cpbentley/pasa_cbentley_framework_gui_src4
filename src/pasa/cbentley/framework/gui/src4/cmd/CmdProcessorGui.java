package pasa.cbentley.framework.gui.src4.cmd;

import pasa.cbentley.core.src4.logging.Dctx;
import pasa.cbentley.framework.cmd.src4.ctx.CmdCtx;
import pasa.cbentley.framework.cmd.src4.engine.CmdFactoryCore;
import pasa.cbentley.framework.cmd.src4.engine.CmdInstance;
import pasa.cbentley.framework.cmd.src4.engine.CmdNode;
import pasa.cbentley.framework.cmd.src4.engine.CmdProcessor;
import pasa.cbentley.framework.cmd.src4.engine.CmdSearch;
import pasa.cbentley.framework.cmd.src4.engine.MCmd;
import pasa.cbentley.framework.cmd.src4.input.CommanderAbstract;
import pasa.cbentley.framework.cmd.src4.interfaces.ICmdListener;
import pasa.cbentley.framework.cmd.src4.interfaces.ICmdsCmd;
import pasa.cbentley.framework.cmd.src4.interfaces.ICommandable;
import pasa.cbentley.framework.cmd.src4.trigger.CmdTrigger;
import pasa.cbentley.framework.core.ui.src4.event.DeviceEvent;
import pasa.cbentley.framework.core.ui.src4.event.GestureArea;
import pasa.cbentley.framework.core.ui.src4.exec.ExecutionContext;
import pasa.cbentley.framework.core.ui.src4.exec.OutputState;
import pasa.cbentley.framework.core.ui.src4.input.InputState;
import pasa.cbentley.framework.core.ui.src4.tech.IInput;
import pasa.cbentley.framework.core.ui.src4.tech.ITechCodes;
import pasa.cbentley.framework.core.ui.src4.tech.ITechInputFeedback;
import pasa.cbentley.framework.core.ui.src4.utils.ViewState;
import pasa.cbentley.framework.gui.src4.canvas.ICanvasDrawable;
import pasa.cbentley.framework.gui.src4.canvas.InputConfig;
import pasa.cbentley.framework.gui.src4.core.Drawable;
import pasa.cbentley.framework.gui.src4.core.UserInteraction;
import pasa.cbentley.framework.gui.src4.ctx.GuiCtx;
import pasa.cbentley.framework.gui.src4.exec.ExecutionContextCanvasGui;
import pasa.cbentley.framework.gui.src4.exec.InputStateCanvasGui;
import pasa.cbentley.framework.gui.src4.exec.OutputStateCanvasGui;
import pasa.cbentley.framework.gui.src4.interfaces.IBOUserInterAction;
import pasa.cbentley.framework.gui.src4.interfaces.ICmdsGui;
import pasa.cbentley.framework.gui.src4.menu.CmdMenuBar;
import pasa.cbentley.framework.gui.src4.string.RequestStringInput;
import pasa.cbentley.framework.gui.src4.table.TableView;
import pasa.cbentley.framework.input.src4.engine.CanvasAppliInput;

/**
 * Implements the Root {@link CmdCtx} commands that require the use of {@link Drawable}s.
 * <br>
 * <br>
 * <li> {@link CmdController#CMD_HELP}
 * <li> {@link CmdController#CMD_CMDS_HISTORY}
 * <li> {@link CmdController#CMD_40_LANGUAGE_CHANGE}
 * <li> {@link CmdController#CMD_HELP}
 * <br>
 * <br>
 * Linked to {@link CmdController#commandAction(CmdInstance)}
 * <br>
 * Basically any Show Menu Something commands will be dealt here.
 * <br>
 * <br>
 * 
 * @author Charles-Philip Bentley
 *
 */
public class CmdProcessorGui extends CmdProcessor implements ICmdsGui, ICommandable, ITechInputFeedback {

   private CmdNode        ctx;

   private CmdNode        modalCtx;

   private int            numUsers;

   private CmdTrigger     patternTrigger;

   private CmdTrigger     patternTriggerPlus;

   private CmdSearch      previousSearch;

   private UserProcessorGui  up;

   protected final GuiCtx gc;

   public CmdProcessorGui(GuiCtx gc) {
      super(gc.getCC());
      this.gc = gc;
      previousSearch = new CmdSearch(cc);
   }

   public void addUser(CommanderAbstract user) {

   }

   public void addUser(CommanderAbstract user, int deviceID) {

   }

   /**
    * Virtual User.
    * Assign a deviceID to the user
    * <br>
    * @param name
    */
   private void addUser(String name, int deviceNameID) {

   }

   public void commandAction(CmdInstance cmd) {
      // TODO Auto-generated method stub

   }

   /**
    * Create a command execution context
    * @param ic
    * @return
    */
   public CmdInstanceGui createCC(ExecutionContextCanvasGui ec, int cmdid) {
      CmdInstanceGui cd = new CmdInstanceGui(gc, cmdid, ec);
      return cd;
   }

   protected CmdFactoryCore createCmdProvider() {
      return new CmdMapperGui(gc);
   }

   public CmdInstance createInstance(MCmd cmd) {
      return new CmdInstanceGui(gc, cmd.getCmdId());
   }

   public CmdInstance createInstance(MCmd cmd, CmdNode ctx, CmdTrigger ct) {
      return new CmdInstanceGui(gc, cmd, ctx, ct);
   }


   /**
    * Executes a {@link MCmd} generated by a menu action. The {@link CmdCtx} used is provided by the Menu.
    * <br>
    * By default, if a menu command is active (i.e. clickable), only the menu {@link CmdCtx} can know how to execute the cmd.
    * <br>
    * <br>
    * If there is no menu {@link CmdCtx} attached, the currently active {@link CmdCtx} is used.
    * <br>
    * 
    * Creates a {@link CmdInstance} that is dispatched to currently focused command listener in the {@link CmdController} hierarchy.
    * <br>
    * <br>
    * 
    * <b>Event Handling</b> <br>
    * {@link TableView} is often used in the same purpose as {@link RequestStringInput}.
    * <br>
    * <li>a {@link MCmd} requires input. Model create a {@link TableView} with its data model to choose data from.
    * <li>Registers as an {@link ICmdListener} to the {@link ICmdsCmd#CMD_ID_SELECT} {@link MCmd}
    * <li>Table is show, User selects, User fire the Selcet Command of the Table.
    * <li>Select cmd has a listener, so fire it. Original caller gets the TableRefence, DataModel, and eventually Data. 
    * <br>
    * Default Event Hook ups for TableView users? Navigation within the table is
    * automatic Selection 
    * <br>
    * <br>
    * @param cmd
    */
   public void executeMenuCmd(MCmd cmd) {
      //get the active context in which the command is executing
      //TODO bug here because active ctx it the menu ctx. what is the target context of a menu
      //the menu target context some navigation events modify the 
      CmdNode activeCtx = cc.getMenuCmdNode();
      CmdTrigger triggerMenu = cc.getMenuTrigger();
      CmdInstance ci = new CmdInstance(cc, cmd, activeCtx, triggerMenu);

      //#debug
      toDLog().pCmd("", ci, CmdProcessorGui.class, "executeMenuCmd@158", LVL_05_FINE, true);

      cc.processCmd(ci);
   }

   public CmdInstance getCI(InputState is) {
      CmdTrigger triggerHotSeat = cc.getTriggerHot();
      CmdNode workCtx = cc.getActiveNode();
      triggerHotSeat.add(is.getKeyCode(), is.getMode(), is.getLastDeviceType());

      //this code use per context mappings. no global mapping

      CmdInstance ci = getCIParent(triggerHotSeat, workCtx);
      if (ci == null) {
         while (ci == null && triggerHotSeat.getSize() != 0) {
            triggerHotSeat.cutTail(1);
            ci = getCIParent(triggerHotSeat, workCtx);
         }
      }
      return ci;
   }

   /**
    * 
    * @param ct
    * @param ctx
    * @return
    */
   public CmdInstance getCIParent(CmdTrigger ct, CmdNode ctx) {
      CmdInstance ci = ctx.hasCmdTrigger(ct);
      while (ctx.getParent() != null && ci == null) {
         ctx = ctx.getParent();
         ci = ctx.hasCmdTrigger(ct);
      }
      return ci;
   }

   public MCmd getCmd(int vcmdid) {
      // TODO Auto-generated method stub
      return null;
   }

   public CmdMenuBar getCmdMenuBar() {
      return getCmdMenuBar();
   }

   public CmdNode getCmdNode() {
      return ctx;
   }

   /**
    * Returns the root model context used to draw exclusive
    * OK/Cancel Input requests
    * @return
    */
   public CmdNode getModalCtx() {
      if (modalCtx == null) {
         modalCtx = cc.getNodeRoot().createChildCtx("Modal");
         CmdTrigger ctFire = cc.getFacTrig().createKeyP(ITechCodes.KEY_FIRE);
         modalCtx.addCmdLink(ctFire, ICmdsCmd.CMD_04_OK);
         CmdTrigger ctEscape = cc.getFacTrig().createKeyP(ITechCodes.KEY_ESCAPE);
         modalCtx.addCmdLink(ctEscape, ICmdsCmd.CMD_05_CANCEL);
      }
      return modalCtx;
   }

   /**
    * The trigger pattern tracks what is pressed
    * @param is
    * @return
    */
   private CmdTrigger getTriggerPatternFromEvent(InputState is) {
      int key1 = is.getKeyCode();
      int key2 = is.getDeviceID();
      int deviceType = is.getLastDeviceType();
      if (is.isModReleased()) {
         int value = CmdTrigger.getIntTriggerUnitDev(key1, key2, IInput.MOD_0_PRESSED, deviceType, IInput.TYPE_1_DEVICE);
         int[] units = patternTrigger.getUnits();
         units = gc.getUC().getIU().remove(units, value);
         patternTrigger = new CmdTrigger(cc, units);
      } else if (is.isModPressed()) {
         patternTrigger.addDevice(key1, key2, IInput.MOD_0_PRESSED, deviceType);
      } else {
         patternTriggerPlus = (CmdTrigger) patternTrigger.clone();
      }
      return patternTrigger;
   }



   //#mdebug


   /**
    * Stores
    * <li> List of commands
    * @return
    */
   public ViewState getViewState() {
      ViewState vs = new ViewState();

      return vs;
   }

   /**
    * Create a {@link CmdInstance} for the view command associated with the ID.
    * <br>
    * Queue up the command for execution in the Update Thread.
    * <br>
    * Method can be called from any thread.
    * <br>
    * A system command is a command executed by code.
    * <br>
    * The root cmdctx of this
    * @param vcmdHome
    * @throws IllegalArgumentException when cmd id is out of range
    */
   public void processCmd(int vcmdID) {
      //at this stage, we have at least once visible canvas
      //a cmd has a rootCanvas associated
      ICanvasDrawable canvasView = gc.getCanvasRoot();
      InputStateCanvasGui isd = (InputStateCanvasGui) canvasView.getEventController().getInputState();
      OutputStateCanvasGui srd = canvasView.getRepaintCtrlDraw().getSD();
      InputConfig ic = new InputConfig(gc, canvasView, isd, srd);

      processCmd(vcmdID, ic);

   }

   public void processCmd(int vcmdID, ExecutionContextCanvasGui ec) {
      //user interaction is used to help user modify things he doesn't like about
      //what just happened.. flag user interaction as slow for example.
      //it is a feedback tool
      //if something unexpected happens the user want to know exactly which commands
      //were executed
      //TODO do we need this stuff then?
      //can be switched off

      //inside this user interaction, hierarchy of user interaction
      UserInteraction ui = new UserInteraction(gc, IBOUserInterAction.TYPE_0_COMMAND);
      gc.getUIACtrl().log(ui);

      //send a cmd event as an input event to be processed by the update thread

      //or create just an empty input state? System Input State flag?

      CmdInstanceGui cd = new CmdInstanceGui(gc, vcmdID);
      OutputState outputState = ec.getOutputState();
      cd.setFeedback(outputState);
      CommanderGui commanderGui = gc.getCommanderGui();

      commanderGui.commandActionDrawable(cd);
   }

   /**
    * Maps current event to a Trigger or a Command
    * <br>
    * <br>
    * If no matching, let the event go to the application method for processing.
    * <br>
    * Non trigger events such as Trail events are Gesture Events, they are forwarded to the command but there are not a trigger per se.
    * <br>
    * Sensor events may also be forwarded to a command that will take action. How?
    * A command is linked to sensor, each event calls method execute of the same instance.
    * Sensors can reflect state (no undo/repeat) or become triggers (with undo/repeat)
    * <br> 
    * Ctrl+Move command will receive events when Ctrl is pressed.
    * But for triggering
    * units like move 90 degrees. Clock wise or Counter clock wise. there must be a event generator
    * when those triggers are used on the context's triggering potentiality.
    * <br>
    * <br>
    * Based on the context of the Event... use the {@link CmdSearch} for it.
    * <br>
    * <li>A mouse 1 event goes to the mouse 1 context, then Mouse 2 context ?
    * <li>A mouse 2 event goes to the mouse 2 context
    * <ol>
    * <li>But if a command depends on a relation with these 2 mouse events? (multi touch)
    * <li>When context is the same for both events, works
    * <li>When context of 2nd mouse event is different, how do we know if mouse 1 press acts as a modifier?
    * <li> Command is linked to M1Press_(#contextID) + M2Press. {@link CmdCtx#getNodeID()}.
    * </ol>
    * <li>A Keyboard 1 event goes to the keyboard 1 context.
    * <li> But if mouse event is over a mixed context, that is? a context with triggers from the keyboard
    * and the mouse or gamepade, the event
    * 
    * <br>
    * <br>
    * <b>Virtual Keyboard simulation of CTRL+PointerPress trigger</b>.<br>
    * One pointer is pressed on CTRL key in virtual keyboard. another pointer is pointing at a position.
    * <br> because both pointer belong to a single User and second pointer occurs on a mixed context.
    * Pointers pointed in the virtualkeyboard are ghost pointers. They belong to a phantom. They are not 
    * a modifier conceptually even though they act as such.
    * <br>
    * A virtual key can be used. The GUI may provide 2 buttons for CTRL and ALT keys.
    * <br>
    * 
    * <br>
    * <b>Multi Persons</b>
    * Person Context can change the event Pointer ID to match a Person. At the level of the input  module,
    * it is done with screen area {@link GestureArea}. There is a trigger search for each person
    * When 2 pointers appear, a priori they both belong to the same user.
    * When User1 tells 2nd pointer is a different User, a new pointer trigger context is created.
    * that will track triggers from user2, independantly of User1 triggers.
    * When is that happening? When automatic, the user identity is computed
    * by application logic inside the call {@link CanvasAppliInput#ctrlUIEvent}
    * <li> static link. user1 defines pointer 2 as belong to user2 always. Done explicitely using a command
    * <li> dynamic link based on pointer press position (Android). Done implicit.
    * In all cases, Pointer 2 becomes Pointer 1 for trigger matching purpose.
    * <br>
    * if(isMultiUserSurface())
    *   computerUser(input state Event) //detect based on position. appli decides context drawable pointed or complex area events
    * Once a pointer press is linked to user2, subsequent drags and release implicitly linked to user2.
    * <br>
    * Commands for each Persons are segregated.
    * Each User has a command history for undo, the Cmd has a User
    * <br>
    * Drag an event from Person 1 to Person 2. Dragging a button from Virtual Keyboard?
    * <br>
    * <br>
    * <br>
    * <li> Ctrl vs Ctrl^ Perfect match. Matcher must check for potential time constraints
    * @param is
    * @param sr
    * @return processing state
    */
   public int processGUIEvent(ExecutionContextCanvasGui ec, InputStateCanvasGui is,  int ctxcat) {
      //if any error, reset all triggers and output log
      try {

         //when we have a device event
         
         //idenfity to which user the event belongs
         UserProcessorGui up = this.up;
         if (numUsers != 1) {
            //we have more than one user.. each user has its own command processor
            up = (UserProcessorGui) getUserProcessor(is);
         }
         if (up != null) {
            //
            return up.processEvent(ec, is);
         } else {
            return ICmdListener.PRO_STATE_0;
         }
      } catch (Exception e) {
         e.printStackTrace();
         //resets dex
         ec.clear();
         return ICmdListener.PRO_STATE_0;
      }
   }

   public int sendEvent(int evType, Object param) {
      // TODO Auto-generated method stub
      return 0;
   }

   public void setCmdCtx(CmdNode c) {
      ctx = c;
   }

   /**
    * Make this command position the most important.
    * <br>
    * It will be shown first in a drop down menu of relevant commands.
    * <br>
    * @param cmd
    */
   public void setTopPriorityCommand(MCmd cmd) {
      getCmdMenuBar().setTopPriorityCommand(cmd);
   }

   //#mdebug
   public void toString(Dctx dc) {
      dc.root(this, CmdProcessorGui.class, 473);
      toStringPrivate(dc);
      super.toString(dc.sup());
   }

   public void toString1Line(Dctx dc) {
      dc.root1Line(this, CmdProcessorGui.class, 479);
      toStringPrivate(dc);
      super.toString1Line(dc.sup1Line());
   }

   private void toStringPrivate(Dctx dc) {

   }
   //#enddebug

}
